// This file is auto-generated by aimpact. It is automatically injected into the development build to
// enable communication with the Aimpact editor via aimpactEditorScript.js.
// This file will be automatically excluded from the production build.
// DO NOT MODIFY THIS FILE. ANY CHANGES WILL BE OVERWRITTEN.
import fs from 'fs';
import path from 'path';

export function aimpactEditorPlugin(configOrOptions = {}) {
  const rootPath = path.resolve(process.cwd(), 'aimpactEditorScript.js');
  const srcPath = path.resolve(process.cwd(), 'src', 'aimpactEditorScript.js');
  const scriptPath = fs.existsSync(srcPath) ? srcPath : rootPath;

  const isNext = configOrOptions.reactStrictMode !== undefined || configOrOptions.webpack !== undefined;

  if (!isNext) {
    return {
      name: 'inject-editor-events-script',
      transformIndexHtml(html) {
        if (!fs.existsSync(scriptPath)) return html;
        const script = fs.readFileSync(scriptPath, 'utf-8');
        return html.replace('</head>', `<script>${script}</script></head>`);
      },
      configureServer(server) {
        server.middlewares.use('/__runtime_error__', (req, res) => {
          let data = '';
          req.on('data', (chunk) => (data += chunk));
          req.on('end', () => {
            console.error('[Runtime Error]', data);
            res.statusCode = 200;
            res.end('ok');
          });
        });
      },
    };
  }

  return {
    ...configOrOptions,
    webpack(config, options) {
      const { isServer, dev } = options;

      if (dev && !isServer) {
        const originalEntry = config.entry;

        config.entry = async () => {
          const entries = await originalEntry();

          const target = entries['main-app'] ? 'main-app' : 'main';

          if (entries[target]) {
            if (Array.isArray(entries[target])) {
              if (!entries[target].includes(scriptPath)) {
                entries[target].unshift(scriptPath);
              }
            } else {
              entries[target] = [scriptPath, entries[target]];
            }
          }
          return entries;
        };
      }

      if (typeof configOrOptions.webpack === 'function') {
        return configOrOptions.webpack(config, options);
      }
      return config;
    },
  };
}
